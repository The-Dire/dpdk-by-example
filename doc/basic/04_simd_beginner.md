# simd扫盲

理解simd首先要明白sisd(Single instructrue single data)单指令单数据。

首先要明确，程序即是指令加数据。而指令作用是给硬件下发任务。

sisd即是一条指令(程序下发的)只能操作一个线程(工作者)且同一时刻只能处理一条数据。

simd出现之前占主导的都是SISD(Single instructrue single data)，但很快人们发现不少场景的特点是逻辑简单，计算量大，而且从算法的角度这些计算还能并行做。

那么最直接的想法是多搞几块芯片并行算呗，就是多核系统，对应到编程层面就是多线程编程的模型。

这么做有一个缺陷:从硬件的角度看利用率十分低下，如果只是为了能并行地计算，只要多搞几套计算元件和寄存器就好了，现在连指令元件，比如取指，比如译码，比如发射，都搞了好几套，这不是浪费吗？

所以很快就有硬件解决了这个问题，让一套指令部件能够带动很多套计算元部件，这套硬件体现在指令集层面就是，单条指令的操作数，从原来的几个，变成了可以一大堆。这就是SIMD。

SIMD很快人们就发现了两个缺陷。

1. 高级语言不好支持，基本上都是靠直接在C语言里嵌汇编来用。导致simd难以维护且写好后难以改动。
2. 用起来很不灵活，比如有时候我一部分位置要做计算，一部分位置不用做计算，这就很处理。

简言之一句话，simd编程比起多线程编程困难不少。

题外话:

***
    为了解决这个问题，英伟达从硬件层面生产了一种设备GPU，GPU本质上跟前面提到的SIMD一样，少量的指令部件带一大堆运算部件。但是英伟达希望能解决掉SIMD的这两个痛点。首先从指令集的设计上，指令就还是像SISD一样，几元运算就是几个操作数，只不过在执行的时候，调度器会给这条指令分套很多套的计算元件和寄存器。这么做带来的第一个好处就是，这样的可执行代码就很容易通过一个一套类似高级语言多线程的编程模式编译而来。这个模式就是大家熟知的CUDA，至此第一个痛点就解决了。上面所说的“一套运算部件和寄存器”，在用户看来就像是一个线程一样，所以这种模式被起名为SIMT。进一步，英伟达给这些指令提供了很多修饰符，比如一个Bit Mask可以指定哪些线程干活，哪些空转，那基于这个设计，SIMT就能很好地支持分支语句了。这样使用起来就很灵活，解决了第二个痛点。所以一句话总结英伟达提出SIMT的初衷就是，希望硬件像SIMD一样高效，编程起来还像多核多线程一样的轻松。
***

介绍完了simd基础概念，下面介绍下simd的基本编程。

# simd编程基础

